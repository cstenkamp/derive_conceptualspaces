# Howto: Docker

See also:
* [Install Docker](https://github.com/cstenkamp/derive_conceptualspaces/blob/main/doc/install_docker.md)
* [Set this project up using Docker](https://github.com/cstenkamp/derive_conceptualspaces/blob/main/doc/setup_container.md)


## What is Docker?

**Docker** is a system which allows you isolate applications into so-called **containers**. Such a container can be compared to a **virtual machine**, except that it is a lot more efficient and doesn't need to additionally contain a complete operating system. These containers are isolated from one another and bundle their software together with all required dependencies, libraries and configuration files. This means, that if a software is bundled into a container, you don't need to install anything on the computer you run the container from (the "host OS"), but can simply download and run the container and be done with it. To create a Docker-Container, you need to write a `Dockerfile` which contains exact, reproducible instructions on what needs to be set up for the virtual operating system inside the container.

Generally, one Docker-Container should contain exactly one service or application. **Docker-Compose** is small convenience-system ontop of docker that allows to easily specify configurations for multiple containers that work together and communicate with each other, like the Postgres-Database and the actual Siddata Backend. A file named `docker-compose.yml` contains the configurations for the individual containers.

### How do I use Docker?

If you do not use docker-compose, you first have to create an `image` from the `Dockerfile` using the command `docker build`. Such an image contains all the required files and can be shared using eg. Dockerhub or the Github Container Registry. To start an image, you need the command `docker run`, which makes a `container` out of the image - you can thus see an `image` as a blueprint of a `container`, while the container is the instantiation of an image (much like classes and objects in OOP). That also means, that the same image can be the basis of multiple containers (which may differ for example depending on which directories from your host OS you mount into the container or what environment-variables you pass to it). If you use docker-compose, the command `docker-compose up` is enough to both build multiple images as required and start the corresponding containers. You can list all images on your system using `docker image ls [-a]` and all containers using `docker container ls [-a]` or `docker ps`.

Once a container is started, it executes whatever was specified as its `entrypoint` (specified in the `Dockerfile`) or `command` (specified in the `docker-compose.yml`). While a container should only execute one thing at a time (and does so really efficiently, in contrast to virtual machines!), you can execute arbitrary programs from running containers (which will invoke a new terminal-session and not interrupt other running processes). As almost all containers are based on some form of Linux, they generally ship with `bash` pre-installed into the containers, which means you can open a terminal inside any container, in which you can then navigate using `cd` and `ls` and execute other stuff from inside the container at will. To open another program from a running container, you can execute `docker exec [-i] [-t] <container_name> <command_to_run>`. Note that the `command_to_run` must either be in a directory that's part of the `PATH` of the container, or you must specify an absolute path to the command. In general however, running `docker exec -it <container_name> bash` should always work, and from there on you can navigate in the container at will. In general, `exec`ing a docker-container behaves pretty much like `sudo` or `ssh` does. Use CTRL+D to exit the session inside the container.
